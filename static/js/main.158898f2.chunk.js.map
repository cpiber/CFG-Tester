{"version":3,"sources":["App/Logic/querys.ts","App/Logic/util.ts","App/Body/GrammarOutput.tsx","App/Logic/set.ts","App/Logic/grammar.ts","App/Logic/fcsgrammar.ts","App/Body/Textarea.tsx","App/Body/RulesInput.tsx","App/Body/TextInput.tsx","App/Body/Body.tsx","App/Footer/Footer.tsx","App/Header/Header.tsx","App/App.tsx","serviceWorker.js","index.js","App/Body/bodyComponent.module.scss","App/Body/textarea.module.scss","App/Body/Body.module.scss","App/Body/GrammarOutput.module.scss"],"names":["Query","createContainer","initialQuery","parse","query","parsed","queryString","rules","input","useState","state","setState","undefined","grammar","setGrammar","setRules","useCallback","nr","setInput","ni","updateQuery","useEffect","update","window","location","hash","addEventListener","removeEventListener","timeout","useRef","current","setTimeout","stringify","clearTimeout","clamp","val","min","max","Math","NUM_KEY","n","localStorage","getItem","GrammarOutput","className","useContainer","Set","strings","setStrings","buttonDisabled","setButtonDisabled","number","setNumber","status","setStatus","grammarUpdated","checkValid","clear","err","stringEls","useMemo","values","map","str","ind","split","key","styles","empty","textarea","area","stylesBody","title","onClick","e","target","tagName","blur","checkClick","i","hasWarn","next","Error","message","add","disabled","type","size","value","onChange","setItem","toString","Symbol","iterator","toStringTag","ComparableSet","other","keys","this","Map","bind","set","delete","callbackfn","thisArg","forEach","v","_","__","call","has","t","f","branchMatch","escapeMatch","escapeNewline","GSymbol","symbol","NonTerminal","Terminal","EmptySymbol","QueueElement","rule","before","depth","nonTerminals","ParseState","left","after","origin","cur","r","prev","reduce","ruleMatchFCS","nonTerminalMatchFCS","FCSGrammar","lines","sym","parseRules","parseNonTerminals","length","line","match","lineToError","toBranches","branchToTerminal","push","j","branch","newbranch","lastIndex","exec","substring","index","string","unescape","replace","console","error","indexOf","initGenerator","gen","maxDepth","maxNonTerms","maxIter","findIndex","s","l","trim","slice","newline","bmatch","prep","newbranches","startsym","generator","g","iterSinceYield","queue","shift","expandTerminal","expandNonTerminal","applicable","nrule","top","topc","k","isFinished","completer","isNonTerminal","predictor","isTerminal","scanner","ns","equals","nextInRule","Textarea","id","placeholder","aria","children","id_","uniqueString","htmlFor","draggable","RulesInput","loadRules","TextInput","res","matches","Body","grid","Provider","initialState","rightTop","rightBottom","Footer","year","Date","getFullYear","beginyear","process","author","source","Fragment","href","rel","Header","App","Boolean","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","module","exports"],"mappings":"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","file":"static/js/main.158898f2.chunk.js","sourcesContent":["import queryString from 'query-string';\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport { createContainer } from 'unstated-next';\nimport type { Grammar } from './grammar';\n\ndeclare global {\n  interface Window {\n    grammar: Grammar | undefined;\n  }\n}\n\nconst useQuery = (initialQuery = \"\") => {\n  const parse = (query: string) => {\n    const parsed = queryString.parse(query);\n    const nr = typeof(parsed.rules) === \"string\" ? parsed.rules : \"\";\n    const ni = typeof(parsed.input) === \"string\" ? parsed.input : \"\";\n    return { rules: nr, input: ni };\n  };\n\n  const [state, setState] = useState(parse(initialQuery));\n  const [grammar, setGrammar] = useState(undefined as Grammar | undefined);\n\n  const setRules = useCallback((nr: string) => setState({ ...state, rules: nr }), [state, setState]);\n  const setInput = useCallback((ni: string) => setState({ ...state, input: ni }), [state, setState]);\n  const updateQuery = useCallback((query: string) => setState(parse(query)), [setState]);\n\n  // detect hash changes, cleanup listener on unmount\n  useEffect(() => {\n    const update = () => updateQuery(window.location.hash);\n    window.addEventListener('hashchange', update);\n    return () => window.removeEventListener('hashchange', update);\n  }, [updateQuery]);\n  \n  // reflect changes in hash, debounce\n  const timeout = useRef(0);\n  useEffect(() => {\n    timeout.current = window.setTimeout(() => window.location.hash = queryString.stringify(state), 100);\n    return () => window.clearTimeout(timeout.current);\n  }, [state]);\n\n  useEffect(() => {\n    window.grammar = grammar;\n  }, [grammar]);\n\n  return { ...state, setRules, setInput, grammar, setGrammar, updateQuery };\n};\n\nconst Query = createContainer(useQuery);\nexport default Query;","export const clamp = (val: number, min: number, max: number) => Math.min(Math.max(val, min), max);","import React, { useEffect, useMemo, useState } from 'react';\nimport Query from '../Logic/querys';\nimport type { Grammar } from '../Logic/grammar';\nimport { clamp } from '../Logic/util';\nimport stylesBody from './bodyComponent.module.scss';\nimport styles from './GrammarOutput.module.scss';\nimport textarea from './textarea.module.scss';\n\n\ninterface Props {\n  className?: string;\n}\n\nconst NUM_KEY = 'cfg_gen_number';\nconst n_min = 1;\nconst n_max = 999;\nconst n = clamp(+(window.localStorage.getItem(NUM_KEY) || 15), n_min, n_max);\n\nconst checkClick = (e: React.MouseEvent, grammar: Grammar | undefined): grammar is Grammar => {\n  if (!e.target) return false;\n  const target = e.target as HTMLElement;\n  \n  if (target.tagName === \"INPUT\") return false;\n  target.blur();\n\n  if (!grammar) return false;\n\n  return true;\n};\n\nconst GrammarOutput = ({ className }: Props) => {\n  const { grammar } = Query.useContainer();\n  const [ strings, setStrings ] = useState(new Set<string>());\n  const [ buttonDisabled, setButtonDisabled ] = useState(false);\n  const [ number, setNumber ] = useState(n);\n  const [ status, setStatus ] = useState([\"\",\"\"]);\n\n  const clickGenerate = (e: React.MouseEvent) => {\n    if (!checkClick(e, grammar))\n      return;\n\n    setButtonDisabled(true);\n    setStatus([\"\", \"\"]);\n\n    let hasWarn = false;\n    let i;\n    for (i = 0; i < number; i++) {\n      const str = grammar.next();\n      if (str === undefined)\n        break;\n      if (str instanceof Error) {\n        hasWarn = true;\n        setStatus([\"warn\", str.message]);\n        break;\n      }\n      strings.add(str);\n    }\n    setStrings(new Set(strings));\n\n    if (i < number && !hasWarn) {\n      setStatus([\"info\", \"Grammar exhausted\"]);\n      return;\n    }\n    setButtonDisabled(false);\n  };\n\n  const clickClear = (e: React.MouseEvent) => {\n    if (!e.target) return;\n    (e.target as HTMLElement).blur();\n\n    grammarUpdated();\n  };\n\n  const updateNum = (e: React.ChangeEvent) => {\n    const val = clamp(+(e.target as HTMLInputElement).value, n_min, n_max);\n    setNumber(val);\n    window.localStorage.setItem(NUM_KEY, val.toString());\n  };\n\n  const grammarUpdated = () => {\n    setStrings(new Set());\n\n    try {\n      grammar?.checkValid();\n      grammar?.clear();\n      setButtonDisabled(false);\n      setStatus([\"\", \"\"]);\n    } catch (err) {\n      setButtonDisabled(true);\n      setStatus([\"error\", `${err}`]);\n    }\n  };\n  useEffect(grammarUpdated, [grammar]);\n\n  const stringEls = useMemo(() => [...strings.values()].map((str, ind) => (\n    <li key={ind} className=\"monospace\">\n      {str.split(/\\r\\n|\\r|\\n|\\\\n/g).map((val, key) => (\n        <span key={key} className={val === '' ? styles.empty : ''}>{val || 'ε'}</span>\n      ))}\n    </li>\n  )), [strings]);\n  \n  return (\n    <div\n      className={`${className || ''} status-${status[0]} App-bodyComponent`}\n    >\n      <div className={`${textarea.area} ${stylesBody.textarea}`}>\n        <h2 className={textarea.title}>Strings</h2>\n        <div className={styles.strings}>\n          <ul>\n            {stringEls}\n          </ul>\n        </div>\n        <div className=\"children\">\n          <div className=\"row1\">\n            <span className=\"status\">\n              {status[1]}\n            </span>\n          </div>\n          <div className=\"row2\">\n            <button\n              className=\"button secondary\"\n              onClick={clickGenerate}\n              disabled={buttonDisabled}\n              aria-label=\"Get more strings\"\n            >\n              Get <input\n                type=\"number\"\n                className=\"input secondary_alt\"\n                size={3}\n                value={number}\n                onChange={updateNum}\n                aria-label=\"Number of strings to get\"\n                /> more\n            </button>\n            <button\n              className=\"button secondary\"\n              onClick={clickClear}\n              aria-label=\"Clear strings\"\n            >\n              Clear\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n};\nexport default GrammarOutput;","export interface Comparable {\n  hash(): string;\n}\n\nclass ComparableSet<V extends Comparable> implements Set<V> {\n  private map: Map<string, V>;\n  clear: () => void;\n  keys: () => IterableIterator<V>;\n  values: () => IterableIterator<V>;\n  [Symbol.iterator]: () => IterableIterator<V>;\n\n  constructor(other?: ComparableSet<V>) {\n    this.map = other ? new Map(other.map) : new Map();\n    this.clear = this.map.clear.bind(this.map);\n    this.keys = this.map.values.bind(this.map);\n    this.values = this.map.values.bind(this.map);\n    this[Symbol.iterator] = this.values;\n  }\n\n  get size() {\n    return this.map.size;\n  }\n  add(value: V): this {\n    this.map.set(value.hash(), value);\n    return this;\n  }\n  delete(value: V): boolean {\n    return this.map.delete(value.hash());\n  }\n  forEach(callbackfn: (value: V, value2: V, set: Set<V>) => void, thisArg?: any): void {\n    this.map.forEach((v, _, __) => callbackfn.call(thisArg, v, v, this), thisArg);\n  }\n  has(value: V): boolean {\n    return this.map.has(value.hash());\n  }\n  entries(): IterableIterator<[V, V]> {\n    const t = this;\n    return (function* () {\n      for (const [, v] of t.map) {\n        yield [v, v] as [V, V];\n      }\n      return undefined;\n    })();\n  }\n  get [Symbol.toStringTag]() { return \"ComparableSet\" };\n}\nexport default ComparableSet;","import ComparableSet, { Comparable } from './set';\n\nexport const branchMatch = /(\\\\*)\\|/g;\nexport const escapeMatch = /(\\\\(?:n|r|t|f))|\\\\(.)/g;\nexport const escapeNewline = /(^|[^\\\\])(\\\\\\\\)*\\\\$/g;\n\nconst EXP_DEPTH = 'cfg_maxdepth'; // to prevent infinite recursion\nconst EXP_NONTERM = 'cfg_maxnonterm'; // maximum non-terminals in a row\nconst EXP_ITER = 'cfg_iter'; // maximum iterations between yields per call\n\nabstract class GSymbol {\n  symbol: string;\n  constructor(symbol: string) {\n    this.symbol = symbol;\n  }\n\n  abstract equals(other: GSymbol): boolean;\n}\nexport class NonTerminal extends GSymbol {\n  equals(other: GSymbol): boolean {\n    return other instanceof NonTerminal && other.symbol === this.symbol;\n  }\n  get [Symbol.toStringTag]() { return \"NonTerminal\" }\n}\nexport class Terminal extends GSymbol {\n  equals(other: GSymbol): boolean {\n    return other instanceof Terminal && other.symbol === this.symbol;\n  }\n  get [Symbol.toStringTag]() { return \"Terminal\" }\n}\nexport class EmptySymbol extends Terminal {\n  constructor() {\n    super(\"\");\n  }\n  get [Symbol.toStringTag]() { return \"EmptySymbol\" }\n}\n\nexport type Rule = (Terminal | NonTerminal)[];\n\nclass QueueElement {\n  rule: Rule;\n  before: string;\n  depth: number;\n  nonTerminals: number;\n  constructor(rule: Rule, before = \"\", depth = 0, nonTerminals = 0) {\n    this.rule = rule;\n    this.before = before;\n    this.depth = depth;\n    this.nonTerminals = nonTerminals;\n  }\n}\n\ntype AnySymbol = Terminal | NonTerminal | undefined;\nclass ParseState<Sym extends AnySymbol = AnySymbol> implements Comparable {\n  left: NonTerminal;\n  before: Rule;\n  symbol: Sym;\n  after: Rule;\n  origin: number;\n  constructor(left: NonTerminal, before: Rule, symbol: Sym, after: Rule, origin: number) {\n    this.left = left;\n    this.before = before;\n    this.symbol = symbol;\n    this.after = after;\n    this.origin = origin;\n  }\n  isFinished(): this is ParseState<undefined> { return this.symbol === undefined || this.symbol instanceof EmptySymbol; }\n  isTerminal(): this is ParseState<Terminal> { return this.symbol instanceof Terminal; }\n  isNonTerminal(): this is ParseState<NonTerminal> { return this.symbol instanceof NonTerminal; }\n\n  hash() {\n    const str = (cur: AnySymbol) => (cur instanceof NonTerminal ? `\\u0001${cur.symbol}\\u0001` : cur?.symbol || '');\n    const r = (prev: string, cur: AnySymbol) => prev + str(cur);\n    return `${this.left.symbol}→${this.before.reduce(r, '')}\\u0002•${str(this.symbol)}${this.after.reduce(r, '')}\\u0003,${this.origin}`;\n  }\n}\ntype ParseStateSet = ComparableSet<ParseState>[];\nexport type { ParseState };\n\nexport abstract class Grammar {\n  private gen: Generator<string | Error, undefined, never> | undefined = undefined;\n  private maxDepth = +(window.localStorage.getItem(EXP_DEPTH) || 20);\n  private maxNonTerms = +(window.localStorage.getItem(EXP_NONTERM) || 10);\n  private maxIter = +(window.localStorage.getItem(EXP_ITER) || 5000);\n\n  protected rules: { [key: string]: Rule[] } = {};\n  abstract clear(): void;\n  abstract matches(str: string): boolean;\n  \n  next(): string | Error | undefined {\n    if (!this.gen)\n      throw new Error(\"Attempted to call .next without a generator, this should never happen!\");\n    return this.gen.next().value;\n  }\n  \n  checkValid(): void {\n    // these are internal sanity checks, they should indeed never happen ;)\n    for (const sym in this.rules) {\n      const rules = this.rules[sym];\n      for (const rule of rules) {\n        if (rule.length === 0)\n          throw new Error('Empty rule, this should never happen!');\n        if (rule.length === 1 && rule[0].symbol === '' && !(rule[0] instanceof EmptySymbol))\n          throw new Error('Empty symbol that isn\\'t an EmptySymbol, this should never happen!');\n        if (rule.length > 1 && rule.findIndex(s => s instanceof EmptySymbol || s.symbol.length === 0) !== -1)\n          throw new Error('EmptySymbol found in a longer rule, this should never happen!');\n      }\n    }\n  }\n\n  protected prepareRules(rules: string) {\n    // remove control characters and split into lines\n    return rules.split(/\\r\\n|\\r|\\n/g).map((l, i, lines) => {\n      const line = l.trim().replace(/[\\u0000-\\u001f\\u007f-\\u009F]/g, '');\n      if (line === \"\") return null; // ignore empty lines\n      if (line.match(escapeNewline)) {\n        if (i + 1 === lines.length)\n          return line.slice(0, line.length - 1);\n        const newline = line.slice(0, line.length - 1) + lines[i + 1].trim();\n        lines[i + 1] = \"\";\n        return newline;\n      }\n      return line;\n    });\n  }\n\n  protected toBranches(branch: string, branchToTerminal: (s: string) => Terminal) {\n    const prep = (str: string) => str.trim().replace(/\\\\n/g, \"\\n\").replace(/\\\\r/g, \"\\r\").replace(/\\\\t/g, \"\\t\").replace(/\\\\f/g, \"\\f\");\n    let newbranches: Terminal[] = [],\n        bmatch: RegExpExecArray | null,\n        lastIndex = 0;\n    while ((bmatch = branchMatch.exec(branch)) !== null) {\n      // even number of backslashes means they are not\n      // escaping the |\n      if (bmatch[1].length % 2 === 0) {\n        const before = branch.substring(lastIndex, bmatch.index + bmatch[1].length);\n        newbranches.push(branchToTerminal(prep(before)));\n        lastIndex = branchMatch.lastIndex;\n      }\n    }\n    const after = branch.substring(lastIndex);\n    newbranches.push(branchToTerminal(prep(after)));\n    return newbranches;\n  }\n\n  protected initGenerator(startsym: string) {\n    const g = this;\n    let iterSinceYield = 0;\n    // search all possible paths using BFS\n    function* generator(queue: QueueElement[]): Generator<string | Error, undefined, never> {\n      let next: QueueElement | undefined;\n      while ((next = queue.shift())) {\n        iterSinceYield ++;\n        let symbol = g.expandTerminal(next);\n        const { rule, before, depth, nonTerminals } = next;\n        if (symbol === undefined) { // no more symbols to process\n          yield before;\n          iterSinceYield = 0;\n          continue;\n        }\n        if (iterSinceYield >= g.maxIter) {\n          yield new Error(`Iterated ${iterSinceYield} times without finding a new value`);\n          iterSinceYield = 0;\n        }\n        if (depth > g.maxDepth || nonTerminals > g.maxNonTerms)\n          continue;\n        g.expandNonTerminal(symbol, rule, queue, next);\n      }\n      return undefined;\n    }\n    this.gen = generator([new QueueElement([new NonTerminal(startsym)])]);\n  }\n\n  private expandTerminal(next: QueueElement) {\n    const rule = next.rule\n    let symbol = rule.shift();\n    while (symbol instanceof Terminal) { // string all terminals together\n      next.before += symbol.symbol;\n      symbol = rule.shift();\n      next.nonTerminals = 0;\n    }\n    return symbol;\n  }\n\n  private expandNonTerminal(symbol: Terminal, rule: Rule, queue: QueueElement[], next: QueueElement) {\n    const { before, depth, nonTerminals } = next;\n    // create a new branch for every possible path\n    const applicable = this.rules[symbol.symbol];\n    for (const nrule of applicable)\n      queue.push(new QueueElement([...nrule, ...rule], before, depth + 1, nonTerminals + 1));\n  }\n\n  protected match(str: string, startsym: string): boolean {\n    // https://en.wikipedia.org/wiki/Earley_parser#Pseudocode\n    const state: ParseStateSet = [];\n    state.push(new ComparableSet());\n    const top  = new ParseState(new NonTerminal(''), [], new NonTerminal(startsym), [], 0);\n    const topc = new ParseState(new NonTerminal(''), [new NonTerminal(startsym)], undefined, [], 0);\n    state[0].add(top);\n\n    // for each 'word'\n    for (let k = 0; k <= str.length; k++) { // need to finish up after the last character\n      state.push(new ComparableSet()); // k+1\n\n      for (const s of state[k]) { // state[k] can expand\n        if (s.isFinished()) {\n          this.completer(s, k, state);\n        } else if (s.isNonTerminal()) {\n          this.predictor(s, k, state);\n        } else if (s.isTerminal()) {\n          this.scanner(s, k, state, str);\n        } else {\n          throw new Error('Unknown symbol type, this should never happen!');\n        }\n      }\n    }\n    \n    return state[str.length].has(topc);\n  }\n\n  private completer(s: ParseState<undefined>, k: number, state: ParseStateSet) {\n    for (const n of state[s.origin]) {\n      if (n.isFinished())\n        continue;\n      const ns = n as ParseState<Terminal | NonTerminal>;\n      if (ns.symbol.equals(s.left))\n        this.nextInRule(ns, k, state);\n    }\n  }\n\n  private predictor(s: ParseState<NonTerminal>, k: number, state: ParseStateSet) {\n    for (const rule of this.rules[s.symbol.symbol]) {\n      state[k].add(new ParseState(s.symbol, [], rule[0], rule.slice(1), k));\n    }\n  }\n\n  private scanner(s: ParseState<Terminal>, k: number, state: ParseStateSet, str: string) {\n    if (k === str.length) // nothing to scan if we're at the end of the string\n      return;\n    if (str[k] === s.symbol.symbol[0]) {\n      this.nextInRule(s, k + 1, state);\n    }\n  }\n\n  private nextInRule(n: ParseState<Terminal | NonTerminal>, k: number, state: ParseStateSet) {\n    // need to go to next symbol in rule\n    // terminals can be multiple chars long, so pop first, otherwise go to next in rule\n    const before = [...n.before];\n    if (n.symbol instanceof Terminal) {\n      const l = before.length - 1;\n      if (before[l] instanceof Terminal) {\n        before[l] = new Terminal(before[l].symbol + n.symbol.symbol[0]);\n      } else {\n        before.push(new Terminal(n.symbol.symbol[0]));\n      }\n    } else {\n      before.push(n.symbol);\n    }\n\n    if (n.symbol instanceof Terminal && n.symbol.symbol.length > 1) {\n      state[k].add(new ParseState(n.left, before, new Terminal(n.symbol.symbol.slice(1)), [...n.after], n.origin));\n    } else {\n      state[k].add(new ParseState(n.left, before, n.after[0], n.after.slice(1), n.origin));\n    }\n  }\n}\n","import { EmptySymbol, escapeMatch, Grammar, NonTerminal, Rule, Terminal } from \"./grammar\";\n\nconst ruleMatchFCS = /^\\s*([A-Z])\\s*(?:->|→)\\s*((?:.|\\n)*)$/m;\nconst nonTerminalMatchFCS = /(\\\\*)([A-Z])/g;\n\nclass FCSGrammar extends Grammar {\n  constructor(rules: string) {\n    super();\n    const lines = super.prepareRules(rules);\n    this.parseRules(lines);\n\n    // check for non-terminals in rules\n    for (const sym in this.rules) {\n      this.parseNonTerminals(this.rules[sym]);\n    }\n  }\n\n  private parseRules(lines: (string | null)[]) {\n    // parse rules into arrays\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      if (line === null)\n        continue;\n      const match = line.match(ruleMatchFCS);\n\n      if (!match)\n        throw new Error(`Syntax error on line ${i + 1}: ${this.lineToError(line)}`);\n\n      const rules = this.toBranches(match[2], this.branchToTerminal).map(t => [t]);\n\n      if (match[1] in this.rules) {\n        this.rules[match[1]].push(...rules);\n      } else {\n        this.rules[match[1]] = rules;\n      }\n    }\n  }\n\n  private parseNonTerminals(rules: Rule[]) {\n    for (let j = 0; j < rules.length; j++) {\n      const branch = rules[j][0].symbol; // currently only 1 terminal symbol, split that\n      let match: RegExpExecArray | null,\n        newbranch: Rule = [],\n        lastIndex = 0;\n\n      while ((match = nonTerminalMatchFCS.exec(branch)) !== null) {\n        // even number of backslashes means they are not\n        // escaping the non-terminal\n        if (match[1].length % 2 === 0 && match[2] in this.rules) {\n          const before = branch.substring(lastIndex, match.index);\n          if (before !== \"\") newbranch.push(this.branchToTerminal(before, true));\n          newbranch.push(new NonTerminal(match[2]));\n          lastIndex = nonTerminalMatchFCS.lastIndex;\n        }\n      }\n      const after = branch.substring(lastIndex);\n      if (after !== \"\") newbranch.push(this.branchToTerminal(after, true));\n\n      if (!newbranch.length) newbranch.push(new EmptySymbol());\n\n      rules[j] = newbranch;\n    }\n  }\n\n  private branchToTerminal(string: string, unescape = false) {\n    return (\n      string === \"^\" || string === \"ε\" || string === \"\" ?\n        new EmptySymbol() :\n        new Terminal(unescape ? string.replace(escapeMatch, \"$1$2\") : string)\n    );\n  }\n\n  private lineToError(line: string) {\n    console.error('Error on line:', line);\n    if (line.indexOf(\"->\") === -1 && line.indexOf(\"→\") === -1)\n      return \"Rule indicator '->' missing\";\n    return \"Non-terminal symbols must be single capital letters\";\n  }\n\n  clear() {\n    this.initGenerator('S');\n  }\n\n  checkValid() {\n    super.checkValid();\n    if (!('S' in this.rules))\n      throw new Error(\"Startsymbol 'S' not found\");\n  }\n\n  matches(str: string) {\n    return super.match(str, 'S');\n  }\n}\n\nexport default FCSGrammar;","import React from 'react';\nimport uniqueString from 'unique-string';\nimport styles from './textarea.module.scss';\n\n\ninterface Props {\n  id?: string;\n  className?: string;\n  title?: string;\n  placeholder?: string;\n  onChange?: ((event: React.ChangeEvent<HTMLTextAreaElement>) => void);\n  value?: string;\n  aria?: string;\n  children?: JSX.Element[] | JSX.Element;\n}\n\nconst Textarea = ({ id, className, title, placeholder, onChange, value, aria, children }: Props) => {\n  const id_ = id || uniqueString();\n  return (\n    <div className={`${styles.area} ${className || ''}`}>\n      {title && (\n        <h2 className={styles.title}>\n          <label htmlFor={id_}>{title}</label>\n        </h2>\n      )}\n      <textarea\n        id={id_}\n        className=\"textarea monospace\"\n        onChange={onChange}\n        draggable=\"false\"\n        placeholder={typeof placeholder === \"string\" ? placeholder : \"Enter text here...\"}\n        value={value}\n        aria-label={aria}\n      ></textarea>\n      {children && (\n        <div className=\"children\">\n          {children}\n        </div>\n      )}\n    </div>\n  )\n};\nexport default Textarea;","import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport FCSGrammar from '../Logic/fcsgrammar';\nimport Query from '../Logic/querys';\nimport styles from './bodyComponent.module.scss';\nimport Textarea from './Textarea';\n\n\ninterface Props {\n  className?: string;\n}\n\nconst RulesInput = ({ className }: Props) => {\n  const { rules, setRules, setGrammar } = Query.useContainer();\n  const [ status, setStatus ] = useState([\"\",\"\"]);\n  const timeout = useRef(0);\n\n  const rulesChange = (e: React.ChangeEvent) => {\n    if (!e.target) return;\n    setRules((e.target as HTMLInputElement).value);\n  };\n\n  const clickGenerate = (e: React.MouseEvent) => {\n    if (!e.target) return;\n    (e.target as HTMLElement).blur();\n\n    loadRules();\n  };\n\n  // parse rules, debounced\n  const loadRules = useCallback(() => {\n    timeout.current = window.setTimeout(() => {\n      try {\n        setGrammar(new FCSGrammar(rules));\n        setStatus([\"ok\", \"\"]);\n      } catch (err) {\n        setStatus([\"error\",`${err}`]);\n      }\n    }, 50);\n    return () => window.clearTimeout(timeout.current);\n  }, [rules, setGrammar]);\n\n  useEffect(loadRules, [rules, loadRules]);\n\n  return (\n    <div\n      className={`${className || ''} status-${status[0]} App-bodyComponent`}\n    >\n      <Textarea\n        className={styles.textarea}\n        value={rules}\n        onChange={rulesChange}\n        title=\"Rules\"\n        aria=\"Rules that describe the grammar\"\n        placeholder=\"Enter rules here... e.g.&#10;S -> 1 | 2 | 3&#10;S -> 4 | 5 | 6\"\n      >\n        <div className=\"row1\">\n          <div className=\"status\">\n            {status[1]}\n          </div>\n        </div>\n        <div className=\"row2\">\n          <button\n            className=\"button secondary\"\n            onClick={clickGenerate}\n          >\n            Regenerate Model\n          </button>\n        </div>\n      </Textarea>\n    </div>\n  )\n};\nexport default RulesInput;","import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport Query from '../Logic/querys';\nimport styles from './bodyComponent.module.scss';\nimport Textarea from './Textarea';\n\n\ninterface Props {\n  className?: string;\n}\n\nconst TextInput = ({ className }: Props) => {\n  const { input, setInput, grammar } = Query.useContainer();\n  const [ status, setStatus ] = useState([\"\", \"\"]);\n  const [ buttonDisabled, setButtonDisabled ] = useState(false);\n  const timeout = useRef(0);\n\n  const inputChange = (e: React.ChangeEvent) => {\n    if (!e.target) return;\n    setInput((e.target as HTMLInputElement).value);\n  }\n  \n  const clickMatch = (e: React.MouseEvent) => {\n    if (!e.target) return;\n    (e.target as HTMLElement).blur();\n\n    match();\n  }\n\n  // match input\n  const match = useCallback(() => {\n    try {\n      if (!grammar)\n        throw new Error('No grammar object available');\n      grammar.checkValid();\n      const res = grammar.matches(input);\n      setButtonDisabled(false);\n      setStatus([res ? 'ok' : 'error', `Input ${res ? 'matches' : 'doesn\\'t match'}`]);\n    } catch (err) {\n      setButtonDisabled(true);\n      setStatus([\"error\", `${err}`]);\n    }\n  }, [input, grammar]);\n\n  // debounce matching, on grammar or input change\n  useEffect(() => {\n    timeout.current = window.setTimeout(match, 100);\n    return () => window.clearTimeout(timeout.current);\n  }, [match]);\n\n  return (\n    <div\n      className={`${className || ''} status-${status[0]} App-bodyComponent`}\n    >\n      <Textarea\n        className={styles.textarea}\n        value={input}\n        onChange={inputChange}\n        title=\"Test Input\"\n        aria=\"Input to match with grammar\"\n      >\n        <div className=\"row1\">\n          <span className=\"status\">\n            {status[1]}\n          </span>\n        </div>\n        <div className=\"row2\">\n          <button\n            className=\"button secondary\"\n            onClick={clickMatch}\n            disabled={buttonDisabled}\n          >\n            Re-Match\n          </button>\n        </div>\n      </Textarea>\n    </div>\n  )\n};\nexport default TextInput;","import React from 'react';\nimport Query from '../Logic/querys';\nimport styles from './Body.module.scss';\nimport GrammarOutput from './GrammarOutput';\nimport RulesInput from './RulesInput';\nimport TextInput from './TextInput';\n\n\ninterface Props {\n  className?: string;\n}\n\nconst Body = ({ className }: Props) => {\n  return (\n    <div\n      className={`${className || ''} ${styles.grid} App-body`}\n    >\n      <Query.Provider initialState={window.location.hash}>\n        <RulesInput\n          className={styles.left}\n        ></RulesInput>\n        <TextInput\n          className={styles.rightTop}\n        ></TextInput>\n        <GrammarOutput\n          className={styles.rightBottom}\n        ></GrammarOutput>\n      </Query.Provider>\n    </div>\n  )\n};\nexport default Body;","import React from 'react';\n\n\ninterface Props {\n  className?: string;\n}\n\nconst Footer = ({ className }: Props) => {\n  const year = (new Date()).getFullYear().toString(),\n    beginyear = process.env.REACT_APP_BEGIN_YEAR,\n    author = process.env.REACT_APP_AUTHOR,\n    source = process.env.REACT_APP_GITHUB_URL,\n    divider = \" :: \";\n\n  return (\n    <footer\n      className={`${className || ''} App-footer`}\n    >\n      {!beginyear || year === beginyear ? year : `${beginyear}-${year}`}\n      {author && ` by ${author}`}\n      {source && (\n        <React.Fragment>\n          <span>{divider}</span>\n          <a href={source} target=\"_blank\" rel=\"noopener noreferrer\">Source</a>\n        </React.Fragment>\n      )}\n    </footer>\n  );\n};\nexport default Footer;","import React from 'react';\n\n\ninterface Props {\n  className?: string;\n}\n\nconst Header = ({ className }: Props) => {\n  return (\n    <header\n      className={`${className || ''} App-header`}\n    >\n      <h1>\n        <abbr title=\"Context-free grammar\">CFG</abbr> Testing suite\n      </h1>\n    </header>\n  );\n};\nexport default Header;","import React from 'react';\nimport './App.scss';\nimport Body from './Body/Body';\nimport Footer from './Footer/Footer';\nimport Header from './Header/Header';\n\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <Header />\n      <Body />\n      <Footer />\n    </div>\n  );\n};\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App/App.tsx';\nimport './index.css';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"textarea\":\"bodyComponent_textarea__2AEVB\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"area\":\"textarea_area__1mQmu\",\"title\":\"textarea_title__3f-Ka\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"grid\":\"Body_grid__2Eze4\",\"left\":\"Body_left__3afN_\",\"rightTop\":\"Body_rightTop__x95CP\",\"rightBottom\":\"Body_rightBottom__2q8gj\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"strings\":\"GrammarOutput_strings__syveZ\",\"empty\":\"GrammarOutput_empty__3tYL_\"};"],"sourceRoot":""}