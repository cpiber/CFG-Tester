{"version":3,"sources":["App/Body/GrammarOutput.module.scss","App/Header/Header.tsx","App/Logic/querys.ts","App/Logic/set.ts","App/Logic/sharedgrammar.ts","App/Logic/fcsgrammar.ts","App/Body/Textarea.tsx","App/Body/RulesInput.tsx","App/Body/TextInput.tsx","App/Logic/util.ts","App/Body/GrammarOutput.tsx","App/Body/Body.tsx","App/Footer/Footer.tsx","App/App.tsx","serviceWorker.js","index.js","App/Body/bodyComponent.module.scss","App/Body/textarea.module.scss","App/Body/Body.module.scss"],"names":["module","exports","Header","props","className","title","Query","createContainer","initialQuery","parse","query","parsed","queryString","rules","input","useState","state","setState","undefined","grammar","setGrammar","setRules","useCallback","nr","setInput","ni","updateQuery","useEffect","update","window","location","hash","addEventListener","removeEventListener","timeout","useRef","current","setTimeout","stringify","clearTimeout","Symbol","iterator","toStringTag","ComparableSet","map","Map","this","values","size","value","set","delete","callbackfn","thisArg","forEach","v","_","__","has","t","f","clear","branchMatch","escapeMatch","GSymbol","symbol","NonTerminal","other","Terminal","EmptySymbol","QueueElement","rule","before","depth","nonTerminals","ParseState","left","after","k","r","prev","cur","reduce","ruleMatchFCS","nonTerminalMatchFCS","FCSGrammar","lines","split","sym","parseRules","parseNonTerminals","regexp","i","length","line","trim","match","Error","lineToError","newbranches","bmatch","lastIndex","exec","substring","index","push","branchToTerminal","j","branch","newbranch","string","escape","replace","indexOf","initGenerator","str","gen","maxDepth","localStorage","getItem","maxNonTerms","maxIter","next","findIndex","s","startsym","generator","g","iterSinceYield","queue","shift","expandTerminal","expandNonTerminal","applicable","nrule","top","topc","add","isFinished","completer","isNonTerminal","predictor","isTerminal","scanner","n","ns","equals","nextInRule","slice","nsym","nrul","Textarea","id","uniqueString","styles","area","htmlFor","onChange","draggable","placeholder","aria","children","RulesInput","useContainer","status","setStatus","loadRules","err","textarea","e","target","onClick","blur","TextInput","buttonDisabled","setButtonDisabled","checkValid","res","matches","disabled","clamp","val","min","max","Math","NUM_KEY","GrammarOutput","Set","strings","setStrings","number","setNumber","grammarUpdated","stringEls","useMemo","ind","toString","key","stylesBody","tagName","checkClick","hasWarn","message","type","setItem","Body","grid","Provider","initialState","rightTop","rightBottom","Footer","year","Date","getFullYear","beginyear","process","author","source","Fragment","href","rel","App","Boolean","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b477f608.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"strings\":\"GrammarOutput_strings__syveZ\"};","import React from 'react';\n\n\ninterface Props {\n  className?: string;\n}\n\nfunction Header(props: Props) {\n  return (\n    <header\n      className={`${props.className || ''} App-header`}\n    >\n      <h1>\n        <abbr title=\"Context-free grammar\">CFG</abbr> Testing suite\n      </h1>\n    </header>\n  );\n}\n\nexport default Header;","import queryString from 'query-string';\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport { createContainer } from 'unstated-next';\nimport type { Grammar } from './sharedgrammar';\n\ndeclare global {\n  interface Window {\n    grammar: Grammar | undefined;\n  }\n}\n\nconst useQuery = (initialQuery = \"\") => {\n  const parse = (query: string) => {\n    const parsed = queryString.parse(query);\n    const nr = typeof(parsed.rules) === \"string\" ? parsed.rules : \"\";\n    const ni = typeof(parsed.input) === \"string\" ? parsed.input : \"\";\n    return { rules: nr, input: ni };\n  };\n\n  const [state, setState] = useState(parse(initialQuery));\n  const [grammar, setGrammar] = useState(undefined as Grammar | undefined);\n\n  const setRules = useCallback((nr: string) => setState({ ...state, rules: nr }), [state, setState]);\n  const setInput = useCallback((ni: string) => setState({ ...state, input: ni }), [state, setState]);\n  const updateQuery = useCallback((query: string) => setState(parse(query)), [setState]);\n\n  // detect hash changes, cleanup listener on unmount\n  useEffect(() => {\n    const update = () => updateQuery(window.location.hash);\n    window.addEventListener('hashchange', update);\n    return () => window.removeEventListener('hashchange', update);\n  }, [updateQuery]);\n  \n  // reflect changes in hash, debounce\n  const timeout = useRef(0);\n  useEffect(() => {\n    timeout.current = window.setTimeout(() => window.location.hash = queryString.stringify(state), 100);\n    return () => window.clearTimeout(timeout.current);\n  }, [state]);\n\n  useEffect(() => {\n    window.grammar = grammar;\n  }, [grammar]);\n\n  return { ...state, setRules, setInput, grammar, setGrammar, updateQuery };\n};\n\nconst Query = createContainer(useQuery);\nexport default Query;","export interface Comparable {\n  hash(): string;\n}\n\nclass ComparableSet<V extends Comparable> implements Set<V> {\n  private map: Map<string, V> = new Map();\n\n  get size() {\n    return this.map.size;\n  }\n  add(value: V): this {\n    this.map.set(value.hash(), value);\n    return this;\n  }\n  delete(value: V): boolean {\n    return this.map.delete(value.hash());\n  }\n  forEach(callbackfn: (value: V, value2: V, set: Set<V>) => void, thisArg?: any): void {\n    this.map.forEach((v, _, __) => callbackfn(v, v, this), thisArg);\n  }\n  has(value: V): boolean {\n    return this.map.has(value.hash());\n  }\n  entries(): IterableIterator<[V, V]> {\n    const t = this;\n    return (function* () {\n      for (const [, v] of t.map) {\n        yield [v, v] as [V, V];\n      }\n      return undefined;\n    })();\n  }\n  clear() { return this.map.clear(); }\n  keys() { return this.map.values(); }\n  values() { return this.map.values(); }\n  [Symbol.iterator] = this.values;\n  [Symbol.toStringTag]: string;\n}\nexport default ComparableSet;","import ComparableSet, { Comparable } from './set';\n(window as any).ComparableSet = ComparableSet;\n\nexport const branchMatch = /(\\\\*)\\|/g;\nexport const escapeMatch = /(\\\\(?:n|r|t|f))|\\\\(.)/g;\n\nconst EXP_DEPTH = 'cfg_maxdepth'; // to prevent infinite recursion\nconst EXP_NONTERM = 'cfg_maxnonterm'; // maximum non-terminals in a row\nconst EXP_ITER = 'cfg_iter'; // maximum iterations between yields per call\n\nabstract class GSymbol {\n  symbol: string;\n  constructor(symbol: string) {\n    this.symbol = symbol;\n  }\n\n  abstract equals(other: GSymbol): boolean;\n}\nexport class NonTerminal extends GSymbol {\n  equals(other: GSymbol): boolean {\n    return other instanceof NonTerminal && other.symbol === this.symbol;\n  }\n}\nexport class Terminal extends GSymbol {\n  equals(other: GSymbol): boolean {\n    return other instanceof Terminal && other.symbol === this.symbol;\n  }\n}\nexport class EmptySymbol extends Terminal {\n  constructor() {\n    super(\"\");\n  }\n}\n\nexport type Rule = (Terminal | NonTerminal)[];\n\nclass QueueElement {\n  rule: Rule;\n  before: string;\n  depth: number;\n  nonTerminals: number;\n  constructor(rule: Rule, before = \"\", depth = 0, nonTerminals = 0) {\n    this.rule = rule;\n    this.before = before;\n    this.depth = depth;\n    this.nonTerminals = nonTerminals;\n  }\n}\n\nclass ParseState<Sym extends Terminal | NonTerminal | undefined = Terminal | NonTerminal | undefined> implements Comparable {\n  left: NonTerminal;\n  before: Rule;\n  symbol: Sym;\n  after: Rule;\n  k: number;\n  constructor(left: NonTerminal, before: Rule, symbol: Sym, after: Rule, k: number) {\n    this.left = left;\n    this.before = before;\n    this.symbol = symbol;\n    this.after = after;\n    this.k = k;\n  }\n  isFinished(): this is ParseState<undefined> { return this.symbol === undefined || this.symbol instanceof EmptySymbol; }\n  isTerminal(): this is ParseState<Terminal> { return this.symbol instanceof Terminal; }\n  isNonTerminal(): this is ParseState<NonTerminal> { return this.symbol instanceof NonTerminal; }\n\n  hash() {\n    const r = (prev: string, cur: Terminal | NonTerminal) => prev + cur.symbol;\n    return `${this.left.symbol}→${this.before.reduce(r, '')}•${this.symbol?.symbol || ''}${this.after.reduce(r, '')},${this.k}`;\n  }\n}\ntype ParseStateSet = ComparableSet<ParseState>[];\n\nexport abstract class Grammar {\n  private gen: Generator<string | Error, undefined, never> | undefined = undefined;\n  private maxDepth = +(window.localStorage.getItem(EXP_DEPTH) || 20);\n  private maxNonTerms = +(window.localStorage.getItem(EXP_NONTERM) || 10);\n  private maxIter = +(window.localStorage.getItem(EXP_ITER) || 5000);\n\n  protected rules: { [key: string]: Rule[] } = {};\n  abstract clear(): void;\n  abstract matches(str: string): boolean;\n  \n  next(): string | Error | undefined {\n    if (!this.gen)\n      throw new Error(\"Attempted to call .next without a generator, this should never happen!\");\n    return this.gen.next().value;\n  }\n  \n  checkValid(): void {\n    // these are internal sanity checks, they should indeed never happen ;)\n    for (const sym in this.rules) {\n      const rules = this.rules[sym];\n      if (rules.length === 0)\n        throw new Error('Empty ruleset, this should never happen!');\n      for (const rule of rules) {\n        if (rule.length === 0)\n          throw new Error('Empty rule, this should never happen!');\n        if (rule.length === 1 && rule[0].symbol === '' && !(rule[0] instanceof EmptySymbol))\n          throw new Error('Empty symbol that isn\\'t an EmptySymbol, this should never happen!');\n        if (rule.length > 1 && rule.findIndex(s => s instanceof EmptySymbol) !== -1)\n          throw new Error('EmptySymbol found in a longer rule, this should never happen!');\n      }\n    }\n  }\n\n  protected initGenerator(startsym: string) {\n    const g = this;\n    let iterSinceYield = 0;\n    // search all possible paths using BFS\n    function* generator(queue: QueueElement[]): Generator<string | Error, undefined, never> {\n      let next: QueueElement | undefined;\n      while ((next = queue.shift())) {\n        iterSinceYield ++;\n        let symbol = g.expandTerminal(next);\n        const { rule, before, depth, nonTerminals } = next;\n        if (symbol === undefined) { // no more symbols to process\n          yield before;\n          iterSinceYield = 0;\n          continue;\n        }\n        if (iterSinceYield >= g.maxIter) {\n          yield new Error(`Iterated ${iterSinceYield} times without finding a new value`);\n          iterSinceYield = 0;\n        }\n        if (depth > g.maxDepth || nonTerminals > g.maxNonTerms)\n          continue;\n        g.expandNonTerminal(symbol, rule, queue, next);\n      }\n      return undefined;\n    }\n    this.gen = generator([new QueueElement([new NonTerminal(startsym)])]);\n  }\n\n  private expandTerminal(next: QueueElement) {\n    const rule = next.rule\n    let symbol = rule.shift();\n    while (symbol instanceof Terminal) { // string all terminals together\n      next.before += symbol.symbol;\n      symbol = rule.shift();\n      next.nonTerminals = 0;\n    }\n    return symbol;\n  }\n\n  private expandNonTerminal(symbol: Terminal, rule: Rule, queue: QueueElement[], next: QueueElement) {\n    const { before, depth, nonTerminals } = next;\n    // create a new branch for every possible path\n    const applicable = this.rules[symbol.symbol];\n    for (const nrule of applicable)\n      queue.push(new QueueElement([...nrule, ...rule], before, depth + 1, nonTerminals + 1));\n  }\n\n  protected match(str: string, startsym: string): boolean {\n    // https://en.wikipedia.org/wiki/Earley_parser#Pseudocode\n    const state: ParseStateSet = [];\n    state.push(new ComparableSet());\n    const top  = new ParseState(new NonTerminal(''), [], new NonTerminal(startsym), [], 0);\n    const topc = new ParseState(new NonTerminal(''), [new NonTerminal(startsym)], undefined, [], 0);\n    state[0].add(top);\n\n    // for each 'word'\n    for (let k = 0; k <= str.length; k++) { // need to finish up after the last character\n      state.push(new ComparableSet()); // k+1\n\n      for (const s of state[k]) { // state[k] can expand\n        if (s.isFinished()) {\n          this.completer(s, k, state);\n        } else if (s.isNonTerminal()) {\n          this.predictor(s, k, state);\n        } else if (s.isTerminal()) {\n          this.scanner(s, k, state, str);\n        } else {\n          throw new Error('Unknown symbol type, this should never happen!');\n        }\n      }\n    }\n\n    return state[str.length].has(topc);\n  }\n\n  private completer(s: ParseState<undefined>, k: number, state: ParseStateSet) {\n    for (const n of state[s.k]) {\n      if (n.isFinished())\n        continue;\n      const ns = n as ParseState<Terminal | NonTerminal>;\n      if (ns.symbol.equals(s.left))\n        this.nextInRule(ns, k, state);\n    }\n  }\n\n  private predictor(s: ParseState<NonTerminal>, k: number, state: ParseStateSet) {\n    for (const rule of this.rules[s.symbol.symbol]) {\n      state[k].add(new ParseState(s.symbol, [], rule[0], rule.slice(1), k));\n    }\n  }\n\n  private scanner(s: ParseState<Terminal>, k: number, state: ParseStateSet, str: string) {\n    if (k === str.length) // nothing to scan if we're at the end of the string\n      return;\n    if (str[k] === s.symbol.symbol[0]) {\n      // need to go to next symbol in rule\n      // terminals can be multiple chars long, so pop first, otherwise go to next in rule\n      if (s.symbol.symbol.length > 1) {\n        state[k+1].add(new ParseState(s.left, [...s.before, new Terminal(s.symbol.symbol[0])], new Terminal(s.symbol.symbol.slice(1)), [...s.after], s.k));\n      } else {\n        this.nextInRule(s, k + 1, state);\n      }\n    }\n  }\n\n  private nextInRule(n: ParseState<Terminal | NonTerminal>, k: number, state: ParseStateSet) {\n    const nsym = n.after.length >= 1 ? n.after[0] : undefined;\n    const nrul = n.after.length >= 1 ? n.after.slice(1) : [];\n    state[k].add(new ParseState(n.left, [...n.before, n.symbol], nsym, nrul, n.k));\n  }\n}\n","import { branchMatch, EmptySymbol, escapeMatch, Grammar, NonTerminal, Rule, Terminal } from \"./sharedgrammar\";\n\nconst ruleMatchFCS = /^\\s*([A-Z])\\s*(?:->|→)\\s*(.*)$/;\nconst nonTerminalMatchFCS = /(\\\\*)([A-Z])/g;\n\nclass FCSGrammar extends Grammar {\n  constructor(rules: string) {\n    super();\n    const lines = rules.split(/\\r\\n|\\r|\\n/g);\n    this.parseRules(lines);\n\n    // check for non-terminals in rules\n    for (const sym in this.rules) {\n      this.parseNonTerminals(this.rules[sym]);\n    }\n  }\n\n  private parseRules(lines: string[]) {\n    const regexp = ruleMatchFCS;\n    // parse rules into arrays\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      if (line.trim() === \"\") continue; // ignore empty lines\n\n      const match = line.match(regexp);\n\n      if (!match)\n        throw new Error(`Syntax error on line ${i + 1}: ${this.lineToError(line)}`);\n\n      let newbranches: Terminal[] = [],\n        bmatch: RegExpExecArray | null,\n        lastIndex = 0;\n      while ((bmatch = branchMatch.exec(match[2])) !== null) {\n        // even number of backslashes means they are not\n        // escaping the |\n        if (bmatch[1].length % 2 === 0) {\n          let before = match[2].substring(lastIndex, bmatch.index + bmatch[1].length);\n          newbranches.push(this.branchToTerminal(before.trim()));\n          lastIndex = branchMatch.lastIndex;\n        }\n      }\n      const after = match[2].substring(lastIndex);\n      newbranches.push(this.branchToTerminal(after.trim()));\n      const rules = newbranches.map(t => [t]);\n\n      if (match[1] in this.rules) {\n        this.rules[match[1]].push(...rules);\n      } else {\n        this.rules[match[1]] = rules;\n      }\n    }\n  }\n\n  private parseNonTerminals(rules: Rule[]) {\n    for (let j = 0; j < rules.length; j++) {\n      const branch = rules[j][0].symbol, // currently only 1 terminal symbol, split that\n        regexp = nonTerminalMatchFCS;\n      let match: RegExpExecArray | null,\n        newbranch: Rule = [],\n        lastIndex = 0;\n\n      while ((match = regexp.exec(branch)) !== null) {\n        // even number of backslashes means they are not\n        // escaping the non-terminal\n        if (match[1].length % 2 === 0 && match[2] in this.rules) {\n          const before = branch.substring(lastIndex, match.index);\n          if (before !== \"\") newbranch.push(this.branchToTerminal(before, true));\n          newbranch.push(new NonTerminal(match[2]));\n          lastIndex = regexp.lastIndex;\n        }\n      }\n      const after = branch.substring(lastIndex).trim();\n      if (after !== \"\") newbranch.push(this.branchToTerminal(after, true));\n\n      if (!newbranch.length) newbranch.push(new EmptySymbol());\n\n      rules[j] = newbranch;\n    }\n  }\n\n  private branchToTerminal(string: string, escape = false) {\n    return (\n      string === \"^\" || string === \"ε\" || string === \"\" ?\n        new EmptySymbol() :\n        new Terminal(escape ? string.replace(escapeMatch, \"$1$2\") : string)\n    );\n  }\n\n  private lineToError(line: string) {\n    if (line.indexOf(\"->\") === -1 && line.indexOf(\"→\") === -1)\n      return \"Rule indicator '->' missing\";\n    return \"Non-terminal symbols must be single capital letters\";\n  }\n\n  clear() {\n    this.initGenerator('S');\n  }\n\n  checkValid() {\n    super.checkValid();\n    if (!('S' in this.rules))\n      throw new Error(\"Startsymbol 'S' not found\");\n  }\n\n  matches(str: string) {\n    return super.match(str, 'S');\n  }\n}\n\nexport default FCSGrammar;","import React from 'react';\nimport uniqueString from 'unique-string';\n\nimport styles from './textarea.module.scss';\n\n\ninterface Props {\n  className?: string;\n  title?: string;\n  placeholder?: string;\n  onChange?: ((event: React.ChangeEvent<HTMLTextAreaElement>) => void);\n  value?: string;\n  aria?: string;\n  children?: JSX.Element[] | JSX.Element;\n  id?: string;\n}\n\nconst Textarea = (props: Props) => {\n  const id = props.id || uniqueString();\n  return (\n    <div className={`${styles.area} ${props.className || ''}`}>\n      {props.title && (\n        <h2 className={styles.title}>\n          <label htmlFor={id}>{props.title}</label>\n        </h2>\n      )}\n      <textarea\n        id={id}\n        className=\"textarea monospace\"\n        onChange={props.onChange}\n        draggable=\"false\"\n        placeholder={props.placeholder?props.placeholder:\"Enter text here...\"}\n        value={props.value}\n        aria-label={props.aria}\n      ></textarea>\n      {props.children && (\n        <div className=\"children\">\n          {props.children}\n        </div>\n      )}\n    </div>\n  )\n}\nexport default Textarea;","import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport FCSGrammar from '../Logic/fcsgrammar';\nimport Query from '../Logic/querys';\nimport styles from './bodyComponent.module.scss';\nimport Textarea from './Textarea';\n\n\ninterface Props {\n  className?: string;\n}\n\nconst RulesInput = (props: Props) => {\n  const { rules, setRules, setGrammar } = Query.useContainer();\n  const [ status, setStatus ] = useState([\"\",\"\"]);\n  const timeout = useRef(0);\n\n  const rulesChange = (e: React.ChangeEvent) => {\n    setRules((e.target as HTMLInputElement).value);\n  };\n\n  const clickGenerate = (e: React.MouseEvent) => {\n    (e.target as HTMLElement).blur();\n    loadRules();\n  };\n\n  // parse rules, debounced\n  const loadRules = useCallback(() => {\n    timeout.current = window.setTimeout(() => {\n      try {\n        setGrammar(new FCSGrammar(rules));\n        setStatus([\"ok\", \"\"]);\n      } catch (err) {\n        setStatus([\"error\",`${err}`]);\n      }\n    }, 50);\n    return () => window.clearTimeout(timeout.current);\n  }, [rules, setGrammar]);\n\n  useEffect(loadRules, [rules, loadRules]);\n\n  return (\n    <div\n      className={`${props.className || ''} status-${status[0]} App-bodyComponent`}\n    >\n      <Textarea\n        className={styles.textarea}\n        value={rules}\n        onChange={rulesChange}\n        title=\"Rules\"\n        aria=\"Rules that describe the grammar\"\n      >\n        <div className=\"row1\">\n          <div className=\"status\">\n            {status[1]}\n          </div>\n        </div>\n        <div className=\"row2\">\n          <button\n            className=\"button secondary\"\n            onClick={clickGenerate}\n          >\n            Regenerate Model\n          </button>\n        </div>\n      </Textarea>\n    </div>\n  )\n}\nexport default RulesInput;","import React, { useState, useRef, useEffect, useCallback } from 'react';\n\nimport styles from './bodyComponent.module.scss';\n\nimport Query from '../Logic/querys';\nimport Textarea from './Textarea';\n\n\ninterface Props {\n  className?: string;\n}\n\nconst TextInput = (props: Props) => {\n  const { input, setInput, grammar } = Query.useContainer();\n  const [ status, setStatus ] = useState([\"\", \"\"]);\n  const [ buttonDisabled, setButtonDisabled ] = useState(false);\n  const timeout = useRef(0);\n\n  const inputChange = (e: React.ChangeEvent) =>\n    setInput((e.target as HTMLInputElement).value);\n  \n  const clickMatch = (e: React.MouseEvent) => {\n    (e.target as HTMLElement).blur();\n    match();\n  }\n\n  // match input\n  const match = useCallback(() => {\n    try {\n      if (!grammar)\n        throw new Error('No grammar object available');\n      grammar.checkValid();\n      const res = grammar.matches(input);\n      setButtonDisabled(false);\n      setStatus([res ? 'ok' : 'error', `Input ${res ? 'matches' : 'doesn\\'t match'}`]);\n    } catch (err) {\n      setButtonDisabled(true);\n      setStatus([\"error\", `${err}`]);\n    }\n  }, [input, grammar]);\n\n  // debounce matching, on grammar or input change\n  useEffect(() => {\n    timeout.current = window.setTimeout(match, 100);\n    return () => window.clearTimeout(timeout.current);\n  }, [match]);\n\n  return (\n    <div\n      className={`${props.className || ''} status-${status[0]} App-bodyComponent`}\n    >\n      <Textarea\n        className={styles.textarea}\n        value={input}\n        onChange={inputChange}\n        title=\"Test Input\"\n        aria=\"Input to match with grammar\"\n      >\n        <div className=\"row1\">\n          <span className=\"status\">\n            {status[1]}\n          </span>\n        </div>\n        <div className=\"row2\">\n          <button\n            className=\"button secondary\"\n            onClick={clickMatch}\n            disabled={buttonDisabled}\n          >\n            Re-Match\n          </button>\n        </div>\n      </Textarea>\n    </div>\n  )\n}\nexport default TextInput;","export const clamp = (val: number, min: number, max: number) => Math.min(Math.max(val, min), max);","import React, { useEffect, useMemo, useState } from 'react';\nimport Query from '../Logic/querys';\nimport type { Grammar } from '../Logic/sharedgrammar';\nimport { clamp } from '../Logic/util';\nimport stylesBody from './bodyComponent.module.scss';\nimport styles from './GrammarOutput.module.scss';\nimport textarea from './textarea.module.scss';\n\n\ninterface Props {\n  className?: string;\n  initialStrings?: string[];\n}\n\nconst NUM_KEY = 'cfg_gen_number';\nconst n_min = 1;\nconst n_max = 999;\nconst n = clamp(+(window.localStorage.getItem(NUM_KEY) || 15), n_min, n_max);\n\nconst checkClick = (e: React.MouseEvent, grammar: Grammar | undefined): grammar is Grammar => {\n  if (!e.target) return false;\n  const target = e.target as HTMLElement;\n  \n  if (target.tagName === \"INPUT\") return false;\n  target.blur();\n\n  if (!grammar) return false;\n\n  return true;\n};\n\nconst GrammarOutput = (props: Props) => {\n  const { grammar } = Query.useContainer();\n  const [ strings, setStrings ] = useState(new Set<string>());\n  const [ buttonDisabled, setButtonDisabled ] = useState(false);\n  const [ number, setNumber ] = useState(n);\n  const [ status, setStatus ] = useState([\"\",\"\"]);\n\n  const clickGenerate = (e: React.MouseEvent) => {\n    if (!checkClick(e, grammar))\n      return;\n\n    setButtonDisabled(true);\n    setStatus([\"\", \"\"]);\n\n    let hasWarn = false;\n    let i;\n    for (i = 0; i < number; i++) {\n      const str = grammar.next();\n      if (str === undefined)\n        break;\n      if (str instanceof Error) {\n        hasWarn = true;\n        setStatus([\"warn\", str.message]);\n        break;\n      }\n      strings.add(str);\n    }\n    setStrings(new Set(strings));\n\n    if (i < number && !hasWarn) {\n      setStatus([\"info\", \"Grammmar exhausted\"]);\n      return;\n    }\n    setButtonDisabled(false);\n  };\n\n  const clickClear = (e: React.MouseEvent) => {\n    if (!e.target) return;\n    (e.target as HTMLElement).blur();\n\n    grammarUpdated();\n  };\n\n  const updateNum = (e: React.ChangeEvent) => {\n    const val = clamp(+(e.target as HTMLInputElement).value, n_min, n_max);\n    setNumber(val);\n    window.localStorage.setItem(NUM_KEY, val.toString());\n  };\n\n  const grammarUpdated = () => {\n    setStrings(new Set());\n\n    try {\n      grammar?.checkValid();\n      grammar?.clear();\n      setButtonDisabled(false);\n      setStatus([\"\", \"\"]);\n    } catch (err) {\n      setButtonDisabled(true);\n      setStatus([\"error\", `${err}`]);\n    }\n  };\n  useEffect(grammarUpdated, [grammar]);\n\n  const stringEls = useMemo(() => [...strings.values()].map((str, ind) => (\n    <li key={ind} className=\"monospace\">\n      {str.toString().split(/\\r\\n|\\r|\\n|\\\\n/g).map((val, key) => (\n        <span key={key}>{val}</span>\n      ))}\n    </li>\n  )), [strings]);\n  \n  return (\n    <div\n      className={`${props.className || ''} status-${status[0]} App-bodyComponent`}\n    >\n      <div className={`${textarea.area} ${stylesBody.textarea}`}>\n        <h2 className={textarea.title}>Strings</h2>\n        <div className={styles.strings}>\n          <ul>\n            {stringEls}\n          </ul>\n        </div>\n        <div className=\"children\">\n          <div className=\"row1\">\n            <span className=\"status\">\n              {status[1]}\n            </span>\n          </div>\n          <div className=\"row2\">\n            <button\n              className=\"button secondary\"\n              onClick={clickGenerate}\n              disabled={buttonDisabled}\n              aria-label=\"Get more strings\"\n            >\n              Get <input\n                type=\"number\"\n                className=\"input secondary_alt\"\n                size={3}\n                value={number}\n                onChange={updateNum}\n                aria-label=\"Number of strings to get\"\n                /> more\n            </button>\n            <button\n              className=\"button secondary\"\n              onClick={clickClear}\n              aria-label=\"Clear strings\"\n            >\n              Clear\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\nexport default GrammarOutput;","import React from 'react';\nimport Query from '../Logic/querys';\nimport styles from './Body.module.scss';\n\nimport RulesInput from './RulesInput';\nimport TextInput from './TextInput';\nimport GrammarOutput from './GrammarOutput';\n\n\ninterface Props {\n  className?: string;\n}\n\nconst Body = (props: Props) => {\n  return (\n    <div\n      className={`${props.className || ''} ${styles.grid} App-body`}\n    >\n      <Query.Provider initialState={window.location.hash}>\n        <RulesInput\n          className={styles.left}\n        ></RulesInput>\n        <TextInput\n          className={styles.rightTop}\n        ></TextInput>\n        <GrammarOutput\n          className={styles.rightBottom}\n        ></GrammarOutput>\n      </Query.Provider>\n    </div>\n  )\n}\nexport default Body;","import React from 'react';\n\n\ninterface Props {\n  className?: string;\n}\n\nfunction Footer(props: Props) {\n  const year = (new Date()).getFullYear().toString(),\n    beginyear = process.env.REACT_APP_BEGIN_YEAR,\n    author = process.env.REACT_APP_AUTHOR,\n    source = process.env.REACT_APP_GITHUB_URL,\n    divider = \" :: \";\n\n  return (\n    <footer\n      className={`${props.className || ''} App-footer`}\n    >\n      {!beginyear || year === beginyear ? year : `${beginyear}-${year}`}\n      {author && ` by ${author}`}\n      {source && (\n        <React.Fragment>\n          <span>{divider}</span>\n          <a href={source} target=\"_blank\" rel=\"noopener noreferrer\">Source</a>\n        </React.Fragment>\n      )}\n    </footer>\n  );\n}\nexport default Footer;","import React from 'react';\nimport './App.scss';\n\nimport Header from './Header/Header';\nimport Body   from './Body/Body';\nimport Footer from './Footer/Footer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Header />\n      <Body />\n      <Footer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App/App.tsx';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"textarea\":\"bodyComponent_textarea__2AEVB\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"area\":\"textarea_area__1mQmu\",\"title\":\"textarea_title__3f-Ka\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"grid\":\"Body_grid__2Eze4\",\"left\":\"Body_left__3afN_\",\"rightTop\":\"Body_rightTop__x95CP\",\"rightBottom\":\"Body_rightBottom__2q8gj\"};"],"sourceRoot":""}